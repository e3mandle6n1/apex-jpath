<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JSONPath Finder</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <script src="https://unpkg.com/jsonpath-plus@10.0.7/dist/index-browser-umd.cjs"></script>
    <style>
      body {
        font-family:
          "Fira Sans", "Helvetica Neue", "Apple SD Gothic Neo", "Malgun Gothic",
          "Segoe UI", sans-serif;
        background-color: #000;
        color: #fff;
        margin: 0;
        display: flex;
        height: 100vh;
        overflow: hidden;
      }

      .container {
        display: flex;
        width: 100%;
      }

      .left-pane,
      .right-pane {
        width: 50%;
        padding: 20px;
        box-sizing: border-box;
        overflow-y: auto;
        height: 100vh;
      }

      .left-pane {
        border-right: 1px solid #333;
        display: flex;
        flex-direction: column;
      }

      .pane-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .pane-header h2 {
        margin: 0;
      }

      #format-json-btn {
        background-color: #333;
        color: #fff;
        border: 1px solid #555;
        border-radius: 5px;
        padding: 4px 12px;
        font-size: 12px;
        cursor: pointer;
      }

      #format-json-btn:hover {
        background-color: #444;
      }

      .search-container {
        margin-bottom: 15px;
        position: relative;
      }

      .mode-toggle-container {
        display: flex;
        gap: 5px;
        margin-bottom: 10px;
      }

      .mode-btn {
        flex: 1;
        background-color: #222;
        color: #888;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 8px 16px;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
        font-family:
          "Fira Sans", "Helvetica Neue", "Apple SD Gothic Neo", "Malgun Gothic",
          "Segoe UI", sans-serif;
        pointer-events: auto;
        position: relative;
        z-index: 1;
      }

      .mode-btn:hover {
        background-color: #2a2a2a;
        border-color: #444;
      }

      .mode-btn.active {
        background-color: #0a0;
        color: #000;
        border-color: #0f0;
        font-weight: bold;
      }

      .search-wrapper {
        position: relative;
        display: flex;
        align-items: center;
      }

      #search-input {
        width: 100%;
        background-color: #111;
        color: #fff;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 10px 70px 10px 10px;
        box-sizing: border-box;
        font-family:
          "Fira Sans", "Helvetica Neue", "Apple SD Gothic Neo", "Malgun Gothic",
          "Segoe UI", sans-serif;
        font-size: 14px;
      }

      #search-input:focus {
        outline: none;
        border-color: #0a0;
      }

      #search-input::placeholder {
        color: #666;
      }

      .search-controls {
        position: absolute;
        right: 10px;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .match-counter {
        color: #666;
        font-size: 12px;
        padding: 0 8px;
        white-space: nowrap;
      }

      .clear-search {
        background: none;
        border: none;
        color: #666;
        cursor: pointer;
        font-size: 18px;
        padding: 0 5px;
        display: none;
      }

      .clear-search:hover {
        color: #fff;
      }

      .clear-search.visible {
        display: block;
      }

      .query-results {
        background-color: #111;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 15px;
        font-family: "Courier New", Courier, monospace;
        font-size: 13px;
      }

      .query-results.hidden {
        display: none;
      }

      .query-results-header {
        color: #0a0;
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .query-results-content {
        background-color: #0a0a0a;
        border: 1px solid #222;
        border-radius: 3px;
        padding: 10px;
        max-height: 200px;
        overflow-y: auto;
        color: #ddd;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .query-error {
        color: #f00;
        background-color: #2a0a0a;
        border: 1px solid #f00;
        border-radius: 3px;
        padding: 10px;
      }

      .apex-code-snippet {
        margin-top: 10px;
        background-color: #0a0a0a;
        border: 1px solid #222;
        border-radius: 3px;
        padding: 10px;
      }

      .apex-code-header {
        color: #569cd6;
        font-weight: bold;
        margin-bottom: 5px;
        font-size: 12px;
      }

      .apex-code {
        color: #ce9178;
        font-family: "Courier New", Courier, monospace;
        font-size: 12px;
      }

      .copy-apex-btn {
        background-color: #333;
        color: #fff;
        border: 1px solid #555;
        border-radius: 3px;
        padding: 4px 10px;
        font-size: 11px;
        cursor: pointer;
        margin-top: 8px;
        font-family:
          "Fira Sans", "Helvetica Neue", "Apple SD Gothic Neo", "Malgun Gothic",
          "Segoe UI", sans-serif;
      }

      .copy-apex-btn:hover {
        background-color: #444;
      }

      .copy-apex-btn.copied {
        background-color: #0a0;
        border-color: #0f0;
        color: #000;
      }

      #json-input {
        width: 100%;
        height: calc(100% - 40px);
        background-color: #111;
        color: #fff;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 10px;
        box-sizing: border-box;
        resize: none;
        font-family: "Courier New", Courier, monospace;
        line-height: 1.5;
      }

      #json-input.error {
        border-color: #f00;
      }

      .error-message {
        background-color: #2a0a0a;
        border: 1px solid #f00;
        border-radius: 5px;
        padding: 15px;
        margin-top: 10px;
        font-family: "Courier New", Courier, monospace;
        font-size: 13px;
      }

      .error-title {
        color: #f00;
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .error-details {
        color: #ff6b6b;
        margin-bottom: 8px;
        line-height: 1.6;
      }

      .error-position {
        color: #ffa500;
        font-weight: bold;
      }

      .error-hint {
        background-color: #1a1a0a;
        border-left: 3px solid #ffa500;
        padding: 8px 10px;
        margin-top: 10px;
        color: #ffeb3b;
        font-size: 12px;
      }

      .error-hint-title {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .error-hint ul {
        margin: 5px 0 0 0;
        padding-left: 20px;
      }

      .error-hint li {
        margin: 3px 0;
      }

      #json-tree {
        padding-left: 20px;
        font-family: "Courier New", monospace;
      }

      .node {
        cursor: pointer;
        padding: 2px 0;
        white-space: nowrap;
      }

      .node.hidden {
        display: none;
      }

      .node.highlight .key,
      .node.highlight .value {
        background-color: #333;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .node.highlight.current-match .key,
      .node.highlight.current-match .value {
        background-color: #0a0;
        color: #000;
      }

      .node .key {
        font-weight: bold;
      }

      .node .value {
        color: #ccc;
      }

      .node .toggle {
        margin-right: 5px;
      }

      .node ul {
        list-style-type: none;
        padding-left: 20px;
        margin: 0;
      }

      .node > ul {
        display: none;
      }

      .node.open > ul {
        display: block;
      }

      .copy-btn {
        display: none;
        margin-left: 10px;
        padding: 2px 8px;
        background-color: #333;
        color: #fff;
        border: 1px solid #555;
        border-radius: 3px;
        cursor: pointer;
        font-size: 11px;
        vertical-align: middle;
      }

      .copy-btn:hover {
        background-color: #555;
      }

      .copy-btn:active {
        background-color: #666;
      }

      .node:hover > .copy-btn {
        display: inline-block;
      }

      .copy-btn.copied {
        background-color: #0a0;
        border-color: #0f0;
      }

      #path-display {
        position: fixed;
        bottom: 0;
        left: 50%;
        width: 50%;
        background-color: #111;
        padding: 15px 20px;
        box-sizing: border-box;
        border-top: 1px solid #333;
        font-family: "Courier New", Courier, monospace;
        color: #0f0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      #path-text {
        flex-grow: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .footer-branding {
        font-family: "Fira Sans", sans-serif;
        font-size: 12px;
        color: #888;
        text-align: right;
        white-space: nowrap;
        margin-left: 20px;
      }

      .footer-branding a {
        color: #aaa;
        text-decoration: none;
      }

      .footer-branding a:hover {
        color: #fff;
        text-decoration: underline;
      }

      .footer-branding .separator {
        margin: 0 8px;
        color: #555;
      }

      .node .value {
        color: #ccc;
      }

      .node .value.string {
        color: #ce9178;
      }

      .node .value.number {
        color: #b5cea8;
      }

      .node .value.boolean {
        color: #569cd6;
      }

      .node .value.null {
        color: #808080;
        font-style: italic;
      }

      .node .toggle {
        margin-right: 5px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="left-pane">
        <div class="pane-header">
          <h2>JSON Input</h2>
          <button id="format-json-btn">Format</button>
        </div>
        <textarea
          id="json-input"
          placeholder='{
  "items": [
    {"name": "A", "price": "12.99"},
    {"name": "B", "price": 12.99},
    {"name": "C", "price": 8}
  ]
}'
        >
{
  "items": [
    {"name": "A", "price": "12.99"},
    {"name": "B", "price": 12.99},
    {"name": "C", "price": 8}
  ]
}</textarea
        >
      </div>
      <div class="right-pane">
        <h2>Hierarchical View</h2>
        <div class="search-container">
          <div class="mode-toggle-container">
            <button id="search-mode-btn" class="mode-btn active">Search</button>
            <button id="query-mode-btn" class="mode-btn">Query</button>
          </div>
          <div class="search-wrapper">
            <input
              type="text"
              id="search-input"
              placeholder="Search nodes (keys or values)..."
            />
            <div class="search-controls">
              <span class="match-counter" id="match-counter"></span>
              <button
                class="clear-search"
                id="clear-search"
                title="Clear search"
              >
                ‚úï
              </button>
            </div>
          </div>
        </div>
        <div id="query-results" class="query-results hidden"></div>
        <div id="json-tree"></div>
      </div>
    </div>
    <div id="path-display">
      <span id="path-text">Path:</span>
      <div class="footer-branding">
        <a
          href="https://github.com/e3mandle6n1/apex-jpath"
          target="_blank"
          rel="noopener noreferrer"
          >apex-jpath</a
        >
        <span class="separator">|</span>
        <span
          >by
          <a
            href="https://github.com/e3mandle6n1"
            target="_blank"
            rel="noopener noreferrer"
            >Emandleni M</a
          ></span
        >
      </div>
    </div>

    <script>
      let currentMatchIndex = -1;
      let matchedNodes = [];
      let currentMode = "search";
      const STORAGE_KEY = "jsonPathFinder_lastInput";

      // Wait for DOM to be ready before accessing elements
      window.addEventListener("DOMContentLoaded", () => {
        console.log("DOMContentLoaded fired!");
        const jsonInput = document.getElementById("json-input");
        const jsonTree = document.getElementById("json-tree");
        const pathText = document.getElementById("path-text");
        const searchInput = document.getElementById("search-input");
        const clearSearchBtn = document.getElementById("clear-search");
        const matchCounter = document.getElementById("match-counter");
        const formatJsonBtn = document.getElementById("format-json-btn");
        const searchModeBtn = document.getElementById("search-mode-btn");
        const queryModeBtn = document.getElementById("query-mode-btn");
        const queryResults = document.getElementById("query-results");

        // Set default query in the search input
        searchInput.value = "$.items[?(@.price >= 12.99)]";
        // Set Query mode as default
        currentMode = "query";
        queryModeBtn.classList.add("active");
        searchModeBtn.classList.remove("active");
        searchInput.placeholder =
          "Enter JSONPath query (e.g., $.items[?(@.price >= 12.99)])...";
        // Remove localStorage loading for first-time demo
        updateJsonView(true);
        executeQuery(searchInput.value);

        console.log("Elements found:", {
          jsonInput: !!jsonInput,
          jsonTree: !!jsonTree,
          searchModeBtn: !!searchModeBtn,
          queryModeBtn: !!queryModeBtn
        });

        // Load saved JSON from localStorage on page load
        const savedJson = localStorage.getItem(STORAGE_KEY);
        if (savedJson) {
          jsonInput.value = savedJson;
        }

        // Parse and display the JSON (either from localStorage or default)
        if (jsonInput.value.trim()) {
          updateJsonView(true);
        }

        /**
         * Updates the JSON tree view by parsing the input and rendering the hierarchical structure.
         * Clears error styling on successful parse, adds error styling and message on failure.
         * @param {boolean} showError - Whether to display error messages in the UI (default: true)
         */
        function updateJsonView(showError = true) {
          try {
            const json = JSON.parse(jsonInput.value);
            jsonTree.innerHTML = createTreeView(json, "$");
            addEventListeners();
            filterNodes(searchInput.value);
            // Clear error styling if parse succeeds
            jsonInput.classList.remove("error");
          } catch (e) {
            jsonInput.classList.add("error");
            if (showError) {
              jsonTree.innerHTML = createErrorMessage(e, jsonInput.value);
            }
          }
        }

        /**
         * Creates a formatted HTML error message with detailed information about JSON parsing errors.
         * Extracts line and column numbers from the error and provides contextual hints for fixing common issues.
         * @param {Error} error - The error object thrown by JSON.parse()
         * @param {string} jsonText - The raw JSON text that failed to parse
         * @returns {string} HTML string containing the formatted error message
         */
        function createErrorMessage(error, jsonText) {
          const errorMsg = error.message;
          let lineNumber = null;
          let columnNumber = null;

          // Try to extract position from error message
          const positionMatch = errorMsg.match(/position (\d+)/i);
          if (positionMatch) {
            const position = parseInt(positionMatch[1]);
            const lines = jsonText.substring(0, position).split("\n");
            lineNumber = lines.length;
            columnNumber = lines[lines.length - 1].length + 1;
          }

          // Common JSON error hints
          const hints = getErrorHints(errorMsg);

          let html = '<div class="error-message">';
          html += '<div class="error-title">‚ùå JSON Parse Error</div>';
          html += `<div class="error-details"><strong>Message:</strong> ${escapeHtml(errorMsg)}</div>`;

          if (lineNumber && columnNumber) {
            html += `<div class="error-details"><span class="error-position">üìç Location:</span> Line ${lineNumber}, Column ${columnNumber}</div>`;
            highlightErrorLine(lineNumber);
          }

          if (hints.length > 0) {
            html += '<div class="error-hint">';
            html += '<div class="error-hint-title">üí° Common fixes:</div>';
            html += "<ul>";
            hints.forEach((hint) => {
              html += `<li>${escapeHtml(hint)}</li>`;
            });
            html += "</ul>";
            html += "</div>";
          }

          html += "</div>";
          return html;
        }

        /**
         * Analyses a JSON parsing error message and returns an array of helpful hints for fixing the issue.
         * Provides context-specific suggestions based on the type of error encountered.
         * @param {string} errorMsg - The error message from JSON.parse()
         * @returns {string[]} Array of hint strings to help users fix the JSON syntax error
         */
        function getErrorHints(errorMsg) {
          const hints = [];
          const lowerMsg = errorMsg.toLowerCase();

          if (
            lowerMsg.includes("unexpected token") ||
            lowerMsg.includes("unexpected string")
          ) {
            hints.push("Check for missing commas between properties");
            hints.push("Ensure all property names are in double quotes");
            hints.push("Look for trailing commas (not allowed in JSON)");
          }

          if (lowerMsg.includes("unexpected end")) {
            hints.push("Check for unclosed braces { } or brackets [ ]");
            hints.push(
              "Verify all strings are properly closed with double quotes"
            );
          }

          if (lowerMsg.includes("'")) {
            hints.push("Use double quotes (\") instead of single quotes (')");
          }

          if (lowerMsg.includes("token")) {
            hints.push("Remove any comments (JSON doesn't support comments)");
            hints.push("Check for special characters that need escaping");
          }

          // Generic helpful hints
          hints.push("Try using an online JSON validator for complex errors");
          hints.push("Use the Format button once JSON is valid to beautify it");

          return hints;
        }

        /**
         * Scrolls the JSON input textarea to highlight the line where a parsing error occurred.
         * @param {number} lineNumber - The line number (1-indexed) where the error was detected
         */
        function highlightErrorLine(lineNumber) {
          const lines = jsonInput.value.split("\n");
          const lineHeight = 1.5;
          const fontSize = 13;
          const scrollPosition = (lineNumber - 1) * (fontSize * lineHeight);

          // Scroll to the error line
          setTimeout(() => {
            jsonInput.scrollTop = scrollPosition - 50;
          }, 100);
        }

        /**
         * Escapes HTML special characters in text to prevent XSS and ensure proper rendering.
         * @param {string} text - The text to escape
         * @returns {string} HTML-safe escaped text
         */
        function escapeHtml(text) {
          const div = document.createElement("div");
          div.textContent = text;
          return div.innerHTML;
        }

        formatJsonBtn.addEventListener("click", () => {
          try {
            const json = JSON.parse(jsonInput.value);
            jsonInput.value = JSON.stringify(json, null, 2);
            localStorage.setItem(STORAGE_KEY, jsonInput.value);
            updateJsonView();
          } catch (e) {
            console.error("Invalid JSON for formatting:", e);
            jsonTree.innerHTML = createErrorMessage(e, jsonInput.value);
            jsonInput.classList.add("error");
          }
        });

        jsonInput.addEventListener("keyup", () => {
          // Save to localStorage whenever input changes
          localStorage.setItem(STORAGE_KEY, jsonInput.value);
          updateJsonView();
        });

        searchInput.addEventListener("input", () => {
          if (currentMode === "search") {
            filterNodes(searchInput.value);
          } else {
            executeQuery(searchInput.value);
          }
          clearSearchBtn.classList.toggle(
            "visible",
            searchInput.value.length > 0
          );
        });

        searchInput.addEventListener("keydown", (e) => {
          if (currentMode === "search") {
            if (e.key === "ArrowDown") {
              e.preventDefault();
              navigateMatches(1);
            } else if (e.key === "ArrowUp") {
              e.preventDefault();
              navigateMatches(-1);
            } else if (e.key === "Escape") {
              clearSearch();
            }
          } else if (currentMode === "query") {
            if (e.key === "Enter") {
              e.preventDefault();
              executeQuery(searchInput.value);
            } else if (e.key === "Escape") {
              clearSearch();
            }
          }
        });

        clearSearchBtn.addEventListener("click", () => {
          clearSearch();
        });

        searchModeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log("Search mode clicked!");
          console.log("searchModeBtn:", searchModeBtn);
          console.log("queryModeBtn:", queryModeBtn);
          currentMode = "search";
          searchModeBtn.classList.add("active");
          queryModeBtn.classList.remove("active");
          searchInput.placeholder = "Search nodes (keys or values)...";
          queryResults.classList.add("hidden");
          clearSearch();
          console.log(
            "Search mode activated, classes:",
            searchModeBtn.className
          );
        });

        queryModeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log("Query mode clicked!");
          console.log("searchModeBtn:", searchModeBtn);
          console.log("queryModeBtn:", queryModeBtn);
          currentMode = "query";
          queryModeBtn.classList.add("active");
          searchModeBtn.classList.remove("active");
          searchInput.placeholder =
            "Enter JSONPath query (e.g., $.items[?(@.price >= 12.99)])...";
          clearSearch();
          console.log("Query mode activated, classes:", queryModeBtn.className);
          if (searchInput.value.trim()) {
            executeQuery(searchInput.value);
          }
        });

        /**
         * Clears the search input field, removes all search highlighting, and resets the filter state.
         */
        function clearSearch() {
          searchInput.value = "";
          clearSearchBtn.classList.remove("visible");
          if (currentMode === "search") {
            filterNodes("");
          } else {
            queryResults.classList.add("hidden");
            queryResults.innerHTML = "";
          }
          searchInput.focus();
        }

        /**
         * Executes a JSONPath query against the parsed JSON and displays the results.
         * Validates that the query is compatible with the Apex library's capabilities.
         * @param {string} query - The JSONPath query expression to execute
         */
        function executeQuery(query) {
          const trimmedQuery = query.trim();

          if (!trimmedQuery) {
            queryResults.classList.add("hidden");
            queryResults.innerHTML = "";
            return;
          }

          try {
            const json = JSON.parse(jsonInput.value);

            const unsupportedFeatures = checkUnsupportedFeatures(trimmedQuery);
            if (unsupportedFeatures) {
              displayQueryError(unsupportedFeatures);
              return;
            }

            const results = JSONPath.JSONPath({
              path: trimmedQuery,
              json: json
            });
            displayQueryResults(trimmedQuery, results);
          } catch (e) {
            if (e.message && e.message.includes("JSON")) {
              displayQueryError(
                "Invalid JSON input. Please fix the JSON before running queries."
              );
            } else {
              displayQueryError(`Query error: ${e.message}`);
            }
          }
        }

        /**
         * Checks if a JSONPath query contains features unsupported by the Apex library.
         * @param {string} query - The JSONPath query to validate
         * @returns {string|null} Error message if unsupported features found, null otherwise
         */
        function checkUnsupportedFeatures(query) {
          if (query.includes("&&") || query.includes("||")) {
            return "Complex filter logic (&&, ||) is not supported in the Apex library. Please use simple filters and chain them in Apex code.";
          }

          if (query.match(/\(.*\)/)) {
            if (!query.includes("[?(") && !query.includes("[*(")) {
              return "Script expressions (...) are not supported in the Apex library for security reasons.";
            }
          }

          if (query.match(/\.(length|avg|sum|min|max|match)\(/)) {
            return "JSONPath functions (.length(), .avg(), etc.) are not supported in the Apex library. Use Apex methods after retrieving data.";
          }

          return null;
        }

        /**
         * Displays query results with formatted output and Apex code snippet.
         * @param {string} query - The executed query
         * @param {Array} results - The query results
         */
        function displayQueryResults(query, results) {
          queryResults.classList.remove("hidden");

          let html = '<div class="query-results-header">‚úì Query Results</div>';
          html += '<div class="query-results-content">';
          html += JSON.stringify(results, null, 2);
          html += "</div>";

          html += generateApexSnippet(query, results);

          queryResults.innerHTML = html;

          const copyBtn = queryResults.querySelector(".copy-apex-btn");
          if (copyBtn) {
            copyBtn.addEventListener("click", () => {
              const apexCode = copyBtn.dataset.code;
              navigator.clipboard
                .writeText(apexCode)
                .then(() => {
                  copyBtn.textContent = "Copied!";
                  copyBtn.classList.add("copied");
                  setTimeout(() => {
                    copyBtn.textContent = "Copy Apex Code";
                    copyBtn.classList.remove("copied");
                  }, 2000);
                })
                .catch((err) => {
                  console.error("Failed to copy:", err);
                });
            });
          }
        }

        /**
         * Displays an error message in the query results panel.
         * @param {string} errorMessage - The error message to display
         */
        function displayQueryError(errorMessage) {
          queryResults.classList.remove("hidden");
          queryResults.innerHTML = `<div class="query-error">‚ùå ${escapeHtml(errorMessage)}</div>`;
        }

        /**
         * Generates Apex code snippet for the given JSONPath query.
         * @param {string} query - The JSONPath query
         * @param {Array} results - The query results (used to determine return type)
         * @returns {string} HTML string containing the Apex code snippet
         */
        function generateApexSnippet(query, results) {
          const resultType =
            Array.isArray(results) && results.length > 0
              ? typeof results[0] === "object"
                ? "List<Object>"
                : "List<Object>"
              : "List<Object>";

          const apexCode = `String jsonString = '...';\nJPath path = new JPath(jsonString);\n\n${resultType} results = (${resultType}) path.select('${query.replace(/'/g, "\\'")}');\n// Returns: ${JSON.stringify(results).substring(0, 100)}${JSON.stringify(results).length > 100 ? "..." : ""}`;

          let html = '<div class="apex-code-snippet">';
          html +=
            '<div class="apex-code-header">Apex Code (for apex-jpath library):</div>';
          html += '<pre class="apex-code">' + escapeHtml(apexCode) + "</pre>";
          html += `<button class="copy-apex-btn" data-code="${escapeHtml(apexCode)}">Copy Apex Code</button>`;
          html += "</div>";

          return html;
        }

        /**
         * Navigates through matched search results in the specified direction.
         * Updates highlighting and scrolls the current match into view.
         * @param {number} direction - Direction to navigate: 1 for next, -1 for previous
         */
        function navigateMatches(direction) {
          if (matchedNodes.length === 0) return;

          if (
            currentMatchIndex >= 0 &&
            currentMatchIndex < matchedNodes.length
          ) {
            matchedNodes[currentMatchIndex].classList.remove("current-match");
          }

          currentMatchIndex += direction;
          if (currentMatchIndex >= matchedNodes.length) {
            currentMatchIndex = 0;
          } else if (currentMatchIndex < 0) {
            currentMatchIndex = matchedNodes.length - 1;
          }

          const currentNode = matchedNodes[currentMatchIndex];
          currentNode.classList.add("current-match");
          currentNode.scrollIntoView({ behavior: "smooth", block: "center" });
          pathText.textContent = `Path: ${currentNode.dataset.path}`;

          updateMatchCounter();
        }

        /**
         * Updates the match counter display to show the current match position out of total matches.
         */
        function updateMatchCounter() {
          if (matchedNodes.length === 0) {
            matchCounter.textContent = "";
          } else {
            matchCounter.textContent = `${currentMatchIndex + 1}/${matchedNodes.length}`;
          }
        }

        /**
         * Filters tree nodes based on a search term, showing only matching nodes and their parents.
         * Highlights matches and automatically expands parent nodes to reveal matched children.
         * @param {string} searchTerm - The search string to filter nodes by (searches keys, values, and paths)
         */
        function filterNodes(searchTerm) {
          const nodes = document.querySelectorAll(".node");
          const lowerSearchTerm = searchTerm.toLowerCase().trim();
          matchedNodes = [];
          currentMatchIndex = -1;

          if (!lowerSearchTerm) {
            nodes.forEach((node) => {
              node.classList.remove("hidden", "highlight", "current-match");
            });
            updateMatchCounter();
            return;
          }

          nodes.forEach((node) => {
            const key = node.querySelector(".key")?.textContent || "";
            const value = node.querySelector(".value")?.textContent || "";
            const pathText = node.dataset.path || "";

            const matches =
              key.toLowerCase().includes(lowerSearchTerm) ||
              value.toLowerCase().includes(lowerSearchTerm) ||
              pathText.toLowerCase().includes(lowerSearchTerm);

            if (matches) {
              node.classList.remove("hidden");
              node.classList.add("highlight");
              matchedNodes.push(node);
              expandParents(node);
            } else {
              node.classList.remove("highlight", "current-match");
              // only check direct children instead of all descendants
              const hasMatchingChild = Array.from(node.children).some(
                (child) => {
                  if (child.tagName === "UL") {
                    return Array.from(child.children).some(
                      (li) =>
                        li.classList.contains("node") &&
                        li.classList.contains("highlight")
                    );
                  }
                  return false;
                }
              );

              if (!hasMatchingChild) {
                node.classList.add("hidden");
              } else {
                node.classList.remove("hidden");
                expandParents(node);
              }
            }
          });

          if (matchedNodes.length > 0) {
            currentMatchIndex = 0;
            matchedNodes[0].classList.add("current-match");
            matchedNodes[0].scrollIntoView({
              behavior: "smooth",
              block: "center"
            });
          }

          updateMatchCounter();
        }

        /**
         * Recursively expands all parent nodes of a given node to make it visible in the tree.
         * @param {HTMLElement} node - The DOM node whose parents should be expanded
         */
        function expandParents(node) {
          let parent = node.parentElement;
          while (parent) {
            const parentNode = parent.closest(".node");
            if (parentNode) {
              parentNode.classList.add("open");
              parentNode.classList.remove("hidden");
              const toggle = parentNode.querySelector(":scope > .toggle");
              if (toggle) {
                toggle.textContent = "-";
              }
              parent = parentNode.parentElement;
            } else {
              break;
            }
          }
        }

        /**
         * Recursively creates an HTML tree view representation of a JSON object.
         * Generates collapsible nodes for objects/arrays and displays primitive values with type styling.
         * @param {*} obj - The JSON object or array to render
         * @param {string} path - The JSONPath string representing the current location in the tree
         * @returns {string} HTML string containing the tree structure
         */
        function createTreeView(obj, path) {
          let html = "<ul>";
          for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
              const newPath = Array.isArray(obj)
                ? `${path}[${key}]`
                : `${path}.${key}`;
              const isObject =
                typeof obj[key] === "object" && obj[key] !== null;

              html += `<li class="node" data-path="${newPath}">`;
              if (isObject) {
                html += '<span class="toggle">+</span>';
              }
              html += `<span class="key">${key}:</span> `;
              if (isObject) {
                html += createTreeView(obj[key], newPath);
              } else {
                const value = obj[key];
                const valueType = value === null ? "null" : typeof value;
                const displayValue = JSON.stringify(value);
                html += `<span class="value ${valueType}">${displayValue}</span>`;
              }
              html += `<button class="copy-btn" title="Copy path">Copy</button>`;
              html += "</li>";
            }
          }
          html += "</ul>";
          return html;
        }

        /**
         * Attaches event listeners to all tree nodes for interactions (hover, toggle, copy).
         * Handles mouseover to display paths, toggle clicks for expand/collapse, and copy button functionality.
         */
        function addEventListeners() {
          const nodes = document.querySelectorAll(".node");
          nodes.forEach((node) => {
            node.addEventListener("mouseover", (event) => {
              event.stopPropagation();
              pathText.textContent = `Path: ${node.dataset.path}`;
            });

            const toggle = node.querySelector(".toggle");
            if (toggle) {
              toggle.addEventListener("click", (event) => {
                event.stopPropagation();
                node.classList.toggle("open");
                toggle.textContent = node.classList.contains("open")
                  ? "-"
                  : "+";
              });
            }

            const copyBtn = node.querySelector(".copy-btn");
            if (copyBtn) {
              copyBtn.addEventListener("click", (event) => {
                event.stopPropagation();
                const path = node.dataset.path;
                navigator.clipboard
                  .writeText(path)
                  .then(() => {
                    copyBtn.textContent = "Copied!";
                    copyBtn.classList.add("copied");
                    setTimeout(() => {
                      copyBtn.textContent = "Copy";
                      copyBtn.classList.remove("copied");
                    }, 1500);
                  })
                  .catch((err) => {
                    console.error("Failed to copy:", err);
                    copyBtn.textContent = "Failed";
                    setTimeout(() => {
                      copyBtn.textContent = "Copy";
                    }, 1500);
                  });
              });
            }
          });
        }

        const formatButton = document.getElementById("format-json-btn");
        if (formatButton) {
          formatButton.click();
        }
      });
    </script>
  </body>
</html>
