<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JSONPath Finder</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <style>
      body {
        font-family:
          "Fira Sans", "Helvetica Neue", "Apple SD Gothic Neo", "Malgun Gothic",
          "Segoe UI", sans-serif;
        background-color: #000;
        color: #fff;
        margin: 0;
        display: flex;
        height: 100vh;
        overflow: hidden;
      }

      .container {
        display: flex;
        width: 100%;
      }

      .left-pane,
      .right-pane {
        width: 50%;
        padding: 20px;
        box-sizing: border-box;
        overflow-y: auto;
        height: 100vh;
      }

      .left-pane {
        border-right: 1px solid #333;
        display: flex;
        flex-direction: column;
      }

      .pane-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .pane-header h2 {
        margin: 0;
      }

      #format-json-btn {
        background-color: #333;
        color: #fff;
        border: 1px solid #555;
        border-radius: 5px;
        padding: 4px 12px;
        font-size: 12px;
        cursor: pointer;
      }

      #format-json-btn:hover {
        background-color: #444;
      }

      .search-container {
        margin-bottom: 15px;
        position: relative;
      }

      .search-wrapper {
        position: relative;
        display: flex;
        align-items: center;
      }

      #search-input {
        width: 100%;
        background-color: #111;
        color: #fff;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 10px 70px 10px 10px;
        box-sizing: border-box;
        font-family:
          "Fira Sans", "Helvetica Neue", "Apple SD Gothic Neo", "Malgun Gothic",
          "Segoe UI", sans-serif;
        font-size: 14px;
      }

      #search-input:focus {
        outline: none;
        border-color: #0a0;
      }

      #search-input::placeholder {
        color: #666;
      }

      .search-controls {
        position: absolute;
        right: 10px;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .match-counter {
        color: #666;
        font-size: 12px;
        padding: 0 8px;
        white-space: nowrap;
      }

      .clear-search {
        background: none;
        border: none;
        color: #666;
        cursor: pointer;
        font-size: 18px;
        padding: 0 5px;
        display: none;
      }

      .clear-search:hover {
        color: #fff;
      }

      .clear-search.visible {
        display: block;
      }

      #json-input {
        width: 100%;
        height: calc(100% - 40px);
        background-color: #111;
        color: #fff;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 10px;
        box-sizing: border-box;
        resize: none;
        font-family: "Courier New", Courier, monospace;
        line-height: 1.5;
      }

      #json-input.error {
        border-color: #f00;
      }

      .error-message {
        background-color: #2a0a0a;
        border: 1px solid #f00;
        border-radius: 5px;
        padding: 15px;
        margin-top: 10px;
        font-family: "Courier New", Courier, monospace;
        font-size: 13px;
      }

      .error-title {
        color: #f00;
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .error-details {
        color: #ff6b6b;
        margin-bottom: 8px;
        line-height: 1.6;
      }

      .error-position {
        color: #ffa500;
        font-weight: bold;
      }

      .error-hint {
        background-color: #1a1a0a;
        border-left: 3px solid #ffa500;
        padding: 8px 10px;
        margin-top: 10px;
        color: #ffeb3b;
        font-size: 12px;
      }

      .error-hint-title {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .error-hint ul {
        margin: 5px 0 0 0;
        padding-left: 20px;
      }

      .error-hint li {
        margin: 3px 0;
      }

      #json-tree {
        padding-left: 20px;
        font-family: "Courier New", Courier, monospace;
      }

      .node {
        cursor: pointer;
        padding: 2px 0;
        white-space: nowrap;
      }

      .node.hidden {
        display: none;
      }

      .node.highlight .key,
      .node.highlight .value {
        background-color: #333;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .node.highlight.current-match .key,
      .node.highlight.current-match .value {
        background-color: #0a0;
        color: #000;
      }

      .node .key {
        font-weight: bold;
      }

      .node .value {
        color: #ccc;
      }

      .node .toggle {
        margin-right: 5px;
      }

      .node ul {
        list-style-type: none;
        padding-left: 20px;
        margin: 0;
      }

      .node > ul {
        display: none;
      }

      .node.open > ul {
        display: block;
      }

      .copy-btn {
        display: none;
        margin-left: 10px;
        padding: 2px 8px;
        background-color: #333;
        color: #fff;
        border: 1px solid #555;
        border-radius: 3px;
        cursor: pointer;
        font-size: 11px;
        vertical-align: middle;
      }

      .copy-btn:hover {
        background-color: #555;
      }

      .copy-btn:active {
        background-color: #666;
      }

      .node:hover > .copy-btn {
        display: inline-block;
      }

      .copy-btn.copied {
        background-color: #0a0;
        border-color: #0f0;
      }

      #path-display {
        position: fixed;
        bottom: 0;
        left: 50%;
        width: 50%;
        background-color: #111;
        padding: 15px 20px;
        box-sizing: border-box;
        border-top: 1px solid #333;
        font-family: "Courier New", Courier, monospace;
        color: #0f0;
      }

      .node .value {
        color: #ccc;
      }

      .node .value.string {
        color: #ce9178;
      }

      .node .value.number {
        color: #b5cea8;
      }

      .node .value.boolean {
        color: #569cd6;
      }

      .node .value.null {
        color: #808080;
        font-style: italic;
      }

      .node .toggle {
        margin-right: 5px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="left-pane">
        <div class="pane-header">
          <h2>JSON Input</h2>
          <button id="format-json-btn">Format</button>
        </div>
        <textarea id="json-input" placeholder="Paste your JSON here...">
{
                "creator": {
                    "name": "Emandleni M",
                    "tagline": "Building the tools I wish I had for others to use and love.",
                    "links": {
                    "github": "https://github.com/e3mandle6n1",
                    "twitter": "https://twitter.com/e3mandle6ni",
                    "trailblazer": "https://trailblazer.me/id/justemandleni",
                    "linkedIn": "https://linkedin.com/in/emandleni-m-994240201/"
                    }
                },
                "techProfile": {
                    "status": "Currently experimenting with Salesforce DX tooling and event-driven patterns.",
                    "primaryStack": {
                    "languages": [
                        { "name": "Apex", "proficiency": "Expert", "focus": "Primary" },
                        { "name": "JavaScript", "proficiency": "Advanced", "focus": "Primary" },
                        { "name": "TypeScript", "proficiency": "Advanced", "focus": "Primary" },
                        { "name": "Python", "proficiency": "Intermediate", "focus": "Secondary" },
                        { "name": "Java", "proficiency": "Intermediate", "focus": "Primary" },
                        { "name": "C#", "proficiency": "Expert", "focus": "Secondary" }
                    ],
                    "frontend": [
                        { "name": "Lightning Web Components (LWC)", "experience": "Expert" },
                        { "name": "React", "experience": "Advanced" },
                        { "name": "Vite", "experience": "Intermediate" }
                    ],
                    "backend": [
                        { "name": "Node.js", "experience": "Advanced" },
                        { "name": "FastAPI", "experience": "Intermediate" }
                    ],
                    "devops": [
                        { "name": "GitHub Actions", "area": "CI/CD Automation" },
                        { "name": "Docker", "area": "Containerization" },
                        { "name": "Salesforce DX (sfDX)", "area": "Salesforce Tooling" },
                        { "name": "GitLab CI", "area": "CI/CD Automation" },
                        { "name": "Copado CLI", "area": "Salesforce DevOps" }
                    ]
                    },
                    "specialties": [
                    {
                        "area": "Salesforce Development",
                        "skills": ["Apex", "LWC", "Salesforce DX", "Unlocked Packages"]
                    },
                    {
                        "area": "API Design & Systems Integration",
                        "skills": ["REST", "SOAP", "GraphQL", "JSON/XML Parsing", "Webhook Integration"]
                    },
                    {
                        "area": "DevOps & Automation",
                        "skills": ["CI/CD Pipelines", "Automated Testing", "Infrastructure as Code (IaC) Principles"]
                    },
                    {
                        "area": "System Architecture",
                        "skills": ["Event-Driven Microservices", "Domain-Driven Design (DDD)"]
                    }
                    ]
                },
                "openSourceProjects": [
                    {
                    "id": "pj_001",
                    "name": "apex-jpath",
                    "description": "A native Apex implementation of JSONPath for querying JSON without full deserialization.",
                    "url": "https://github.com/e3mandle6n1/apex-jpath",
                    "isFeatured": true,
                    "stats": { "stars": 204, "forks": 42, "watchers": 12, "openIssues": 3 },
                    "technologies": ["Apex", "RegEx", "JavaScript"],
                    "release": { "latestVersion": "v1.5.0", "packageId": "04t5p000000Gf3vAAC", "license": "MIT" }
                    },
                    {
                    "id": "pj_002",
                    "name": "apex-xpath",
                    "description": "Planned: A native Apex XPath parser for complex XML document traversal.",
                    "url": "",
                    "isFeatured": false,
                    "stats": { "stars": 5, "forks": 1, "watchers": 3, "openIssues": 1 },
                    "technologies": ["Apex", "XML", "DOM"],
                    "release": { "latestVersion": "v0.1.0-alpha", "packageId": null, "license": "MIT" }
                    },
                    {
                    "id": "pj_003",
                    "name": "x-x-equipment",
                    "description": "Internal: x x x-x/x system.",
                    "url": null,
                    "isFeatured": false,
                    "stats": null,
                    "technologies": ["Python", "FastAPI", "React", "Docker"],
                    "release": null
                    }
                ],
                "meta": {
                    "lastUpdated": "2025-11-11T10:32:30Z",
                    "schemaVersion": "2.2-dev"
                }
}</textarea
        >
      </div>
      <div class="right-pane">
        <h2>Hierarchical View</h2>
        <div class="search-container">
          <div class="search-wrapper">
            <input
              type="text"
              id="search-input"
              placeholder="Search nodes (keys or values)..."
            />
            <div class="search-controls">
              <span class="match-counter" id="match-counter"></span>
              <button
                class="clear-search"
                id="clear-search"
                title="Clear search"
              >
                ‚úï
              </button>
            </div>
          </div>
        </div>
        <div id="json-tree"></div>
      </div>
    </div>
    <div id="path-display">Path:</div>

    <script>
      const jsonInput = document.getElementById("json-input");
      const jsonTree = document.getElementById("json-tree");
      const pathDisplay = document.getElementById("path-display");
      const searchInput = document.getElementById("search-input");
      const clearSearchBtn = document.getElementById("clear-search");
      const matchCounter = document.getElementById("match-counter");
      const formatJsonBtn = document.getElementById("format-json-btn");

      let currentMatchIndex = -1;
      let matchedNodes = [];
      const STORAGE_KEY = "jsonPathFinder_lastInput";

      // Load saved JSON from localStorage on page load
      window.addEventListener("DOMContentLoaded", () => {
        const savedJson = localStorage.getItem(STORAGE_KEY);
        if (savedJson) {
          jsonInput.value = savedJson;
          updateJsonView(false);
        }
      });

      /**
       * Updates the JSON tree view by parsing the input and rendering the hierarchical structure.
       * Clears error styling on successful parse, adds error styling and message on failure.
       * @param {boolean} showError - Whether to display error messages in the UI (default: true)
       */
      function updateJsonView(showError = true) {
        try {
          const json = JSON.parse(jsonInput.value);
          jsonTree.innerHTML = createTreeView(json, "$");
          addEventListeners();
          filterNodes(searchInput.value);
          // Clear error styling if parse succeeds
          jsonInput.classList.remove("error");
        } catch (e) {
          jsonInput.classList.add("error");
          if (showError) {
            jsonTree.innerHTML = createErrorMessage(e, jsonInput.value);
          }
        }
      }

      /**
       * Creates a formatted HTML error message with detailed information about JSON parsing errors.
       * Extracts line and column numbers from the error and provides contextual hints for fixing common issues.
       * @param {Error} error - The error object thrown by JSON.parse()
       * @param {string} jsonText - The raw JSON text that failed to parse
       * @returns {string} HTML string containing the formatted error message
       */
      function createErrorMessage(error, jsonText) {
        const errorMsg = error.message;
        let lineNumber = null;
        let columnNumber = null;

        // Try to extract position from error message
        const positionMatch = errorMsg.match(/position (\d+)/i);
        if (positionMatch) {
          const position = parseInt(positionMatch[1]);
          const lines = jsonText.substring(0, position).split("\n");
          lineNumber = lines.length;
          columnNumber = lines[lines.length - 1].length + 1;
        }

        // Common JSON error hints
        const hints = getErrorHints(errorMsg);

        let html = '<div class="error-message">';
        html += '<div class="error-title">‚ùå JSON Parse Error</div>';
        html += `<div class="error-details"><strong>Message:</strong> ${escapeHtml(errorMsg)}</div>`;

        if (lineNumber && columnNumber) {
          html += `<div class="error-details"><span class="error-position">üìç Location:</span> Line ${lineNumber}, Column ${columnNumber}</div>`;
          highlightErrorLine(lineNumber);
        }

        if (hints.length > 0) {
          html += '<div class="error-hint">';
          html += '<div class="error-hint-title">üí° Common fixes:</div>';
          html += "<ul>";
          hints.forEach((hint) => {
            html += `<li>${escapeHtml(hint)}</li>`;
          });
          html += "</ul>";
          html += "</div>";
        }

        html += "</div>";
        return html;
      }

      /**
       * Analyses a JSON parsing error message and returns an array of helpful hints for fixing the issue.
       * Provides context-specific suggestions based on the type of error encountered.
       * @param {string} errorMsg - The error message from JSON.parse()
       * @returns {string[]} Array of hint strings to help users fix the JSON syntax error
       */
      function getErrorHints(errorMsg) {
        const hints = [];
        const lowerMsg = errorMsg.toLowerCase();

        if (
          lowerMsg.includes("unexpected token") ||
          lowerMsg.includes("unexpected string")
        ) {
          hints.push("Check for missing commas between properties");
          hints.push("Ensure all property names are in double quotes");
          hints.push("Look for trailing commas (not allowed in JSON)");
        }

        if (lowerMsg.includes("unexpected end")) {
          hints.push("Check for unclosed braces { } or brackets [ ]");
          hints.push(
            "Verify all strings are properly closed with double quotes"
          );
        }

        if (lowerMsg.includes("'")) {
          hints.push("Use double quotes (\") instead of single quotes (')");
        }

        if (lowerMsg.includes("token")) {
          hints.push("Remove any comments (JSON doesn't support comments)");
          hints.push("Check for special characters that need escaping");
        }

        // Generic helpful hints
        hints.push("Try using an online JSON validator for complex errors");
        hints.push("Use the Format button once JSON is valid to beautify it");

        return hints;
      }

      /**
       * Scrolls the JSON input textarea to highlight the line where a parsing error occurred.
       * @param {number} lineNumber - The line number (1-indexed) where the error was detected
       */
      function highlightErrorLine(lineNumber) {
        const lines = jsonInput.value.split("\n");
        const lineHeight = 1.5; // matches CSS line-height
        const fontSize = 13; // approximate font size
        const scrollPosition = (lineNumber - 1) * (fontSize * lineHeight);

        // Scroll to the error line
        setTimeout(() => {
          jsonInput.scrollTop = scrollPosition - 50;
        }, 100);
      }

      /**
       * Escapes HTML special characters in text to prevent XSS and ensure proper rendering.
       * @param {string} text - The text to escape
       * @returns {string} HTML-safe escaped text
       */
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      formatJsonBtn.addEventListener("click", () => {
        try {
          const json = JSON.parse(jsonInput.value);
          jsonInput.value = JSON.stringify(json, null, 2);
          localStorage.setItem(STORAGE_KEY, jsonInput.value);
          updateJsonView();
        } catch (e) {
          console.error("Invalid JSON for formatting:", e);
          jsonTree.innerHTML = createErrorMessage(e, jsonInput.value);
          jsonInput.classList.add("error");
        }
      });

      jsonInput.addEventListener("keyup", () => {
        // Save to localStorage whenever input changes
        localStorage.setItem(STORAGE_KEY, jsonInput.value);
        updateJsonView();
      });

      searchInput.addEventListener("input", () => {
        filterNodes(searchInput.value);
        clearSearchBtn.classList.toggle(
          "visible",
          searchInput.value.length > 0
        );
      });

      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "ArrowDown") {
          e.preventDefault();
          navigateMatches(1);
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          navigateMatches(-1);
        } else if (e.key === "Escape") {
          clearSearch();
        }
      });

      clearSearchBtn.addEventListener("click", () => {
        clearSearch();
      });

      /**
       * Clears the search input field, removes all search highlighting, and resets the filter state.
       */
      function clearSearch() {
        searchInput.value = "";
        clearSearchBtn.classList.remove("visible");
        filterNodes("");
        searchInput.focus();
      }

      /**
       * Navigates through matched search results in the specified direction.
       * Updates highlighting and scrolls the current match into view.
       * @param {number} direction - Direction to navigate: 1 for next, -1 for previous
       */
      function navigateMatches(direction) {
        if (matchedNodes.length === 0) return;

        if (currentMatchIndex >= 0 && currentMatchIndex < matchedNodes.length) {
          matchedNodes[currentMatchIndex].classList.remove("current-match");
        }

        currentMatchIndex += direction;
        if (currentMatchIndex >= matchedNodes.length) {
          currentMatchIndex = 0;
        } else if (currentMatchIndex < 0) {
          currentMatchIndex = matchedNodes.length - 1;
        }

        const currentNode = matchedNodes[currentMatchIndex];
        currentNode.classList.add("current-match");
        currentNode.scrollIntoView({ behavior: "smooth", block: "center" });
        pathDisplay.textContent = `Path: ${currentNode.dataset.path}`;

        updateMatchCounter();
      }

      /**
       * Updates the match counter display to show the current match position out of total matches.
       */
      function updateMatchCounter() {
        if (matchedNodes.length === 0) {
          matchCounter.textContent = "";
        } else {
          matchCounter.textContent = `${currentMatchIndex + 1}/${matchedNodes.length}`;
        }
      }

      /**
       * Filters tree nodes based on a search term, showing only matching nodes and their parents.
       * Highlights matches and automatically expands parent nodes to reveal matched children.
       * @param {string} searchTerm - The search string to filter nodes by (searches keys, values, and paths)
       */
      function filterNodes(searchTerm) {
        const nodes = document.querySelectorAll(".node");
        const lowerSearchTerm = searchTerm.toLowerCase().trim();
        matchedNodes = [];
        currentMatchIndex = -1;

        if (!lowerSearchTerm) {
          nodes.forEach((node) => {
            node.classList.remove("hidden", "highlight", "current-match");
          });
          updateMatchCounter();
          return;
        }

        nodes.forEach((node) => {
          const key = node.querySelector(".key")?.textContent || "";
          const value = node.querySelector(".value")?.textContent || "";
          const pathText = node.dataset.path || "";

          const matches =
            key.toLowerCase().includes(lowerSearchTerm) ||
            value.toLowerCase().includes(lowerSearchTerm) ||
            pathText.toLowerCase().includes(lowerSearchTerm);

          if (matches) {
            node.classList.remove("hidden");
            node.classList.add("highlight");
            matchedNodes.push(node);
            expandParents(node);
          } else {
            node.classList.remove("highlight", "current-match");
            // only check direct children instead of all descendants
            const hasMatchingChild = Array.from(node.children).some((child) => {
              if (child.tagName === "UL") {
                return Array.from(child.children).some(
                  (li) =>
                    li.classList.contains("node") &&
                    li.classList.contains("highlight")
                );
              }
              return false;
            });

            if (!hasMatchingChild) {
              node.classList.add("hidden");
            } else {
              node.classList.remove("hidden");
              expandParents(node);
            }
          }
        });

        if (matchedNodes.length > 0) {
          currentMatchIndex = 0;
          matchedNodes[0].classList.add("current-match");
          matchedNodes[0].scrollIntoView({
            behavior: "smooth",
            block: "center"
          });
        }

        updateMatchCounter();
      }

      /**
       * Recursively expands all parent nodes of a given node to make it visible in the tree.
       * @param {HTMLElement} node - The DOM node whose parents should be expanded
       */
      function expandParents(node) {
        let parent = node.parentElement;
        while (parent) {
          const parentNode = parent.closest(".node");
          if (parentNode) {
            parentNode.classList.add("open");
            parentNode.classList.remove("hidden");
            const toggle = parentNode.querySelector(":scope > .toggle");
            if (toggle) {
              toggle.textContent = "-";
            }
            parent = parentNode.parentElement;
          } else {
            break;
          }
        }
      }

      /**
       * Recursively creates an HTML tree view representation of a JSON object.
       * Generates collapsible nodes for objects/arrays and displays primitive values with type styling.
       * @param {*} obj - The JSON object or array to render
       * @param {string} path - The JSONPath string representing the current location in the tree
       * @returns {string} HTML string containing the tree structure
       */
      function createTreeView(obj, path) {
        let html = "<ul>";
        for (const key in obj) {
          if (obj.hasOwnProperty(key)) {
            const newPath = Array.isArray(obj)
              ? `${path}[${key}]`
              : `${path}.${key}`;
            const isObject = typeof obj[key] === "object" && obj[key] !== null;

            html += `<li class="node" data-path="${newPath}">`;
            if (isObject) {
              html += '<span class="toggle">+</span>';
            }
            html += `<span class="key">${key}:</span> `;
            if (isObject) {
              html += createTreeView(obj[key], newPath);
            } else {
              const value = obj[key];
              const valueType = value === null ? "null" : typeof value;
              const displayValue = JSON.stringify(value);
              html += `<span class="value ${valueType}">${displayValue}</span>`;
            }
            html += `<button class="copy-btn" title="Copy path">Copy</button>`;
            html += "</li>";
          }
        }
        html += "</ul>";
        return html;
      }

      /**
       * Attaches event listeners to all tree nodes for interactions (hover, toggle, copy).
       * Handles mouseover to display paths, toggle clicks for expand/collapse, and copy button functionality.
       */
      function addEventListeners() {
        const nodes = document.querySelectorAll(".node");
        nodes.forEach((node) => {
          node.addEventListener("mouseover", (event) => {
            event.stopPropagation();
            pathDisplay.textContent = `Path: ${node.dataset.path}`;
          });

          const toggle = node.querySelector(".toggle");
          if (toggle) {
            toggle.addEventListener("click", (event) => {
              event.stopPropagation();
              node.classList.toggle("open");
              toggle.textContent = node.classList.contains("open") ? "-" : "+";
            });
          }

          const copyBtn = node.querySelector(".copy-btn");
          if (copyBtn) {
            copyBtn.addEventListener("click", (event) => {
              event.stopPropagation();
              const path = node.dataset.path;
              navigator.clipboard
                .writeText(path)
                .then(() => {
                  copyBtn.textContent = "Copied!";
                  copyBtn.classList.add("copied");
                  setTimeout(() => {
                    copyBtn.textContent = "Copy";
                    copyBtn.classList.remove("copied");
                  }, 1500);
                })
                .catch((err) => {
                  console.error("Failed to copy:", err);
                  copyBtn.textContent = "Failed";
                  setTimeout(() => {
                    copyBtn.textContent = "Copy";
                  }, 1500);
                });
            });
          }
        });
      }
    </script>
  </body>
</html>
